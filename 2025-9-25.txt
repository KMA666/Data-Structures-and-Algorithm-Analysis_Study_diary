2025年9月25日

---------------------

//开始系统学习数据结构与算法了，如果明天和罗老师交流顺利，就进组做科研，更需要算法基础了，所以得好好学！


一、线性表的核心定义与逻辑特征
1. 定义
线性表是由n（n≥0）个具有相同数据类型的数据元素构成的有限序列，通常表示为：L = (a₁, a₂, ..., aᵢ, aᵢ₊₁, ..., aₙ)
n 称为线性表的长度：当 n=0 时，称为 “空表”；当 n>0 时，称为 “非空表”。
aᵢ（1≤i≤n）：表示第 i 个元素，i 称为该元素的位序（注意：位序从 1 开始，与数组下标从 0 开始区分）。
逻辑关系：a₁ 是首元素（无前驱），aₙ 是尾元素（无后继）；对 2≤i≤n-1 的元素 aᵢ，其直接前驱是 aᵢ₋₁，直接后继是 aᵢ₊₁。
2. 关键逻辑特征
线性性：数据元素的逻辑顺序与存储顺序（或访问顺序）一致，呈现 “一条直线” 的结构，无分支、无循环。
同构性：所有元素的数据类型必须相同（如全为整数、全为字符串），确保操作的一致性。
有限性：元素个数是有限的，便于计算机内存分配和操作控制。
二、线性表的两种核心存储结构
线性表的存储结构决定了其操作效率（如插入、删除、查找的时间复杂度），主要分为 “顺序存储” 和 “链式存储” 两大类，二者各有优劣，适用于不同场景。
1. 顺序存储结构：顺序表（Sequential List）
定义
顺序表是用一段地址连续的存储单元依次存储线性表中的元素，本质是 “数组的抽象实现”（数组是顺序表的物理载体）。由于地址连续，元素的物理位置与逻辑位序严格对应 —— 即 aᵢ 的存储地址可通过公式直接计算。
存储地址计算
假设每个元素占用 k 个存储单元，首元素 a₁ 的地址为 LOC(a₁)，则第 i 个元素的地址为：LOC(aᵢ) = LOC(a₁) + (i-1) × k这一特性使得顺序表的随机访问（按位查找） 效率极高。

优缺点
优点：
存储密度高（无额外空间存储逻辑关系，所有空间均用于存元素）；
随机访问速度快（O (1) 时间复杂度）。
缺点：
插入 / 删除操作效率低（需移动大量元素）；
静态顺序表（固定大小数组）存在 “内存溢出” 或 “空间浪费” 问题（动态顺序表虽可扩容，但扩容需拷贝元素，有额外开销）；
内存需连续分配，不适合存储大型或元素个数频繁变化的线性表。

基本操作及时间复杂度
操作	描述	时间复杂度	说明
按位查找（GetElem）	查找第 i 个元素	O(1)	直接通过地址公式计算，无需遍历
按值查找（LocateElem）	查找值为 e 的元素首次出现的位置	O(n)	需从首元素开始遍历，最坏情况查完所有元素
插入（ListInsert）	在第 i 个位置插入元素 e	O(n)	需移动 n-i+1 个元素（从后往前移）
删除（ListDelete）	删除第 i 个位置的元素	O(n)	需移动 n-i 个元素（从前往后移）
初始化（InitList）	创建一个空的顺序表	O(1)	仅需分配内存并设置长度为 0
求长度（ListLength）	获取线性表的元素个数	O(1)	直接读取长度变量


2. 链式存储结构：链表（Linked List）
定义
链表是用地址不连续的存储单元存储线性表元素，为了体现 “一对一” 的逻辑关系，每个元素（称为 “结点”）除了存储自身数据（数据域），还需存储其直接后继的地址（指针域 / 引用域）。链表的元素逻辑顺序由指针域的指向决定，物理存储顺序可任意，无需连续内存。
常见链表类型
根据指针域的数量和指向，链表可分为多种类型，核心类型如下：
类型	结构特点	适用场景
单链表（Singly Linked List）	每个结点含 1 个指针域，仅指向直接后继；需头指针（指向首结点），尾结点指针为 NULL	只需单向遍历、操作简单的场景（如简单列表）
双链表（Doubly Linked List）	每个结点含 2 个指针域（前驱指针 + 后继指针），可双向遍历	需频繁向前 / 向后遍历的场景（如浏览器历史记录）
循环链表（Circular Linked List）	尾结点指针不指向 NULL，而是指向首结点（单循环）或头结点（双循环），形成闭环	需循环访问所有元素的场景（如约瑟夫环问题）
静态链表（Static Linked List）	用数组模拟链表（数组元素含数据域和 “游标”，代替指针），内存连续	不支持指针的编程语言（如早期 Basic），或需连续内存的嵌入式场景
单链表（最基础类型）的操作与时间复杂度
单链表的操作依赖指针遍历，无随机访问能力，因此时间复杂度与顺序表差异显著：
操作	描述	时间复杂度	说明
按位查找（GetElem）	查找第 i 个元素	O(n)	需从首结点开始，通过指针依次遍历 i-1 次
按值查找（LocateElem）	查找值为 e 的元素首次出现的位置	O(n)	需从首结点开始遍历，最坏情况查完所有结点
头插法（InsertHead）	在链表头部插入元素 e	O(1)	只需创建新结点，修改指针指向，无需遍历
尾插法（InsertTail）	在链表尾部插入元素 e	O(n)	需先遍历到尾结点（若无尾指针则为 O (n)；有尾指针可优化为 O (1)）
按位插入（InsertPos）	在第 i 个位置插入元素 e	O(n)	需遍历到第 i-1 个结点（前驱结点）
按位删除（DeletePos）	删除第 i 个位置的元素	O(n)	需遍历到第 i-1 个结点，修改其指针
初始化（InitList）	创建一个空链表（仅头指针，无结点）	O(1)	只需定义头指针并置为 NULL
求长度（ListLength）	获取链表的结点个数	O(n)	需遍历所有结点，计数统计
优缺点
优点：
插入 / 删除操作效率高（无需移动元素，仅需修改指针，头插 / 尾插可优化为 O (1)）；
内存无需连续分配，可动态申请结点，避免空间浪费或溢出；
适合存储元素个数频繁变化、需频繁插入 / 删除的线性表。
缺点：
存储密度低（每个结点需额外存储指针域，占用更多内存）；
无随机访问能力（按位 / 按值查找需遍历，效率为 O (n)）；
依赖指针 / 引用，若指针操作不当（如野指针、断链），易导致程序错误。


三、顺序表与链表的核心对比
选择哪种存储结构，需根据实际场景的 “操作需求” 和 “数据特征” 决定，二者的核心差异如下：
对比维度	顺序表（Sequential List）	链表（Linked List）
存储方式	地址连续的存储单元	地址不连续的存储单元（结点 + 指针）
随机访问	支持（O (1)）	不支持（O (n)）
插入 / 删除效率	低（O (n)，需移动元素）	高（O (1)，仅改指针；遍历找位置为 O (n)）
存储密度	高（100%，无额外开销）	低（需存储指针，额外开销约 50%~100%）
内存分配	静态 / 动态连续分配	动态离散分配
适用场景	频繁查找、元素个数稳定的场景（如数据库索引）	频繁插入 / 删除、元素个数多变的场景（如链表式队列）
实现复杂度	简单（依赖数组，操作直观）	较复杂（需处理指针，避免断链 / 野指针）


四、线性表的应用场景
线性表是许多高级数据结构和算法的基础，其典型应用包括：
数组（Array）：本质是顺序表的具体实现，广泛用于存储批量同类型数据（如矩阵、列表）。
栈（Stack）：“先进后出”（LIFO）的线性表，可基于顺序表（顺序栈）或链表（链栈）实现，用于表达式求值、函数调用栈、括号匹配等。
队列（Queue）：“先进先出”（FIFO）的线性表，可基于顺序表（循环队列）或链表（链队列）实现，用于任务调度、消息队列、缓冲处理等。
字符串（String）：特殊的线性表（元素为字符），通常用顺序表存储，用于文本处理、字符串匹配等。
邻接表（Adjacency List）：图的一种存储结构，本质是 “链表的数组”，用于存储稀疏图（边数少的图）。


五、总结
线性表的核心是 “一对一” 的逻辑关系，其存储结构（顺序表 / 链表）决定了操作效率的 Trade-off（权衡）：
若场景以查找为主，元素个数稳定，优先选择顺序表；
若场景以插入 / 删除为主，元素个数多变，优先选择链表。